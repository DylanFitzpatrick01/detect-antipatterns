# <- type = PUNCTUATION
include <- type = IDENTIFIER
< <- type = PUNCTUATION
iostream <- type = IDENTIFIER
> <- type = PUNCTUATION
# <- type = PUNCTUATION
include <- type = IDENTIFIER
< <- type = PUNCTUATION
string <- type = IDENTIFIER
> <- type = PUNCTUATION
struct <- type = KEYWORD
Contact <- type = IDENTIFIER
{ <- type = PUNCTUATION
const <- type = KEYWORD
std <- type = IDENTIFIER
:: <- type = PUNCTUATION
string <- type = IDENTIFIER
name <- type = IDENTIFIER
; <- type = PUNCTUATION
const <- type = KEYWORD
std <- type = IDENTIFIER
:: <- type = PUNCTUATION
string <- type = IDENTIFIER
address <- type = IDENTIFIER
; <- type = PUNCTUATION
const <- type = KEYWORD
std <- type = IDENTIFIER
:: <- type = PUNCTUATION
string <- type = IDENTIFIER
timezone <- type = IDENTIFIER
; <- type = PUNCTUATION
const <- type = KEYWORD
bool <- type = KEYWORD
isActive <- type = IDENTIFIER
; <- type = PUNCTUATION
std <- type = IDENTIFIER
:: <- type = PUNCTUATION
string <- type = IDENTIFIER
dateOfBirth <- type = IDENTIFIER
; <- type = PUNCTUATION
} <- type = PUNCTUATION
; <- type = PUNCTUATION
// So what's wrong here?  <- type = COMMENT
// We have a concept called "immutable objects" which basically means that all of the state inside the object  <- type = COMMENT
// is const (another way of saying that it cannot change after the object is created). <- type = COMMENT
// Immutable objects are inherently thread safe as no one can write to any of the members, so its safe to have <- type = COMMENT
// concurrent readers, even without locks/mutexes. <- type = COMMENT
// However, it's easy to forget to mark one member as const, therefore making the object not immuatable. <- type = COMMENT
int <- type = KEYWORD
main <- type = IDENTIFIER
( <- type = PUNCTUATION
) <- type = PUNCTUATION
{ <- type = PUNCTUATION
auto <- type = KEYWORD
contactRecord <- type = IDENTIFIER
= <- type = PUNCTUATION
Contact <- type = IDENTIFIER
{ <- type = PUNCTUATION
"Joe Blogs" <- type = LITERAL
, <- type = PUNCTUATION
"123 Fake Street" <- type = LITERAL
, <- type = PUNCTUATION
"Europe/Dublin" <- type = LITERAL
, <- type = PUNCTUATION
true <- type = KEYWORD
, <- type = PUNCTUATION
"2000/01/01" <- type = LITERAL
} <- type = PUNCTUATION
; <- type = PUNCTUATION
//contactRecord.name = "Steve";             // Doesnt compile as name is a const member.  <- type = COMMENT
contactRecord <- type = IDENTIFIER
. <- type = PUNCTUATION
dateOfBirth <- type = IDENTIFIER
= <- type = PUNCTUATION
"1999/12/25" <- type = LITERAL
; <- type = PUNCTUATION
// Uh-oh, this object isnt immutable after all! <- type = COMMENT
} <- type = PUNCTUATION
// We should be able to detect when something "looks like" it was intended to be immutable (nearly all the  <- type = COMMENT
// members are const), but we then have one member that isnt const. <- type = COMMENT
// This isnt a hard rule as we cannot fully know the intent of the programmer. But, it is a suspicous  <- type = COMMENT
// pattern and we can build a hueristic around it, and provide a warning.  <- type = COMMENT
// "Are you sure you want just this one member you're adding to be non const? The object is no longer immutable." <- type = COMMENT
